# üöÄ Essential Algorithms for Beginners and Interviews

This repository summarizes 12 must-know algorithms that form the foundation of problem-solving in data structures and algorithms. These are highly useful in coding interviews, competitive programming, and real-world applications.

## 1Ô∏è‚É£ Linear Search
**Purpose:** Search for a target element in an unsorted array by checking each element one by one.

**Use Case:** When the list is small or unsorted.

- Time Complexity: O(n)
- Space Complexity: O(1)


## 2Ô∏è‚É£ Binary Search
**Purpose:** Search a sorted array by repeatedly dividing the search interval in half.

**Use Case**: Fast search in a sorted list.

- Time Complexity: O(log n)
- Space Complexity: O(1)

## 3Ô∏è‚É£ Bubble Sort
**Purpose:** Repeatedly swap adjacent elements if they are in the wrong order until the list is sorted.

**Use Case:** Educational, not practical for large datasets.

- Time Complexity: O(n¬≤)
- Space Complexity: O(1)

## 4Ô∏è‚É£ Selection Sort
**Purpose:** Select the minimum element from the unsorted portion and move it to the beginning.

**Use Case:** Simple to understand, but inefficient for large datasets.
- Time Complexity: O(n¬≤)
- Space Complexity: O(1)

## 5Ô∏è‚É£ Insertion Sort
**Purpose:** Build the final sorted array one item at a time by shifting elements.

**Use Case:** Efficient for small or nearly sorted data.

- Time Complexity: O(n¬≤)
- Space Complexity: O(1)

## 6Ô∏è‚É£ Merge Sort
**Purpose:** Divide the array, sort the halves recursively, and then merge them.

**Use Case:** Stable and efficient for large datasets.
**Time Complexity: O(n log n)
Space Complexity: O(n)**

## 7Ô∏è‚É£ Quick Sort
**Purpose:** Select a pivot, partition the array around it, and recursively sort partitions.

**Use Case:** Fast and widely used; may degrade to O(n¬≤) in worst case.

- Time Complexity: O(n log n) on average
- Space Complexity: O(log n) (due to recursion)

## 8Ô∏è‚É£ Two Pointers Technique
**Purpose:** Use two pointers to solve problems in linear time, such as finding pairs or palindromes.

**Use Case:** Searching in sorted arrays, string problems, etc.

- Time Complexity: O(n)
- Space Complexity: O(1)

## 9Ô∏è‚É£ Sliding Window Technique
**Purpose:** Maintain a window of elements and slide it to efficiently compute values like max sum.

**Use Case:** Subarray problems, average/max/min in window.

- Time Complexity: O(n)
- Space Complexity: O(1)

## üîü Kadane‚Äôs Algorithm
**Purpose:** Find the maximum sum of a contiguous subarray.

**Use Case:** Dynamic programming problem for subarray sums.

- Time Complexity: O(n)
- Space Complexity: O(1)

## 1Ô∏è‚É£1Ô∏è‚É£ Prefix Sum & Difference Arrays
**Purpose:** Precompute cumulative values for fast range queries.

**Use Case:** Fast subarray sum, range updates.

- Time Complexity: O(n) preprocessing, O(1) query
- Space Complexity: O(n)

## 1Ô∏è‚É£2Ô∏è‚É£ Flood Fill Algorithm (DFS/BFS)
**Purpose:** Fill all connected cells of the same color/region in a grid.

**Use Case:** Grid-based problems, image editing tools (like paint bucket).

- Time Complexity: O(m √ó n)
- Space Complexity: O(m √ó n) (due to recursion or queue)

## ‚úÖ Summary Table

| Algorithm            | Best For                       | Time Complexity | Space Complexity |
| -------------------- | ------------------------------ | --------------- | ---------------- |
| Linear Search        | Unsorted search                | O(n)            | O(1)             |
| Binary Search        | Sorted search                  | O(log n)        | O(1)             |
| Bubble Sort          | Learning sorting basics        | O(n¬≤)           | O(1)             |
| Selection Sort       | Simple sorting                 | O(n¬≤)           | O(1)             |
| Insertion Sort       | Small/almost sorted arrays     | O(n¬≤)           | O(1)             |
| Merge Sort           | Large/stable sorting           | O(n log n)      | O(n)             |
| Quick Sort           | Efficient general-purpose sort | O(n log n) avg  | O(log n)         |
| Two Pointers         | Optimized linear scans         | O(n)            | O(1)             |
| Sliding Window       | Subarray/window problems       | O(n)            | O(1)             |
| Kadane‚Äôs Algorithm   | Max subarray sum               | O(n)            | O(1)             |
| Prefix Sum           | Fast range queries             | O(n)            | O(n)             |
| Flood Fill (DFS/BFS) | Grid/region filling            | O(m √ó n)        | O(m √ó n)         |

### üìå Note
**This repository is designed to help students, developers, and job seekers quickly revise essential algorithms with clear explanations and practical use cases.**

Feel free to ‚≠ê the repo if you found it useful and also give me suggestion to add anything and feel free to connect with me on Linkedin if you find any difficulty..!


